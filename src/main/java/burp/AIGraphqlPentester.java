package burp;

import burp.api.montoya.BurpExtension;
import burp.api.montoya.MontoyaApi;
import burp.api.montoya.extension.ExtensionUnloadingHandler;
import burp.api.montoya.EnhancedCapability;
import burp.api.montoya.http.Http;
import burp.api.montoya.http.message.requests.HttpRequest;
import burp.api.montoya.http.message.responses.HttpResponse;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.logging.Logging;
import burp.api.montoya.ai.Ai;
import burp.api.montoya.ai.chat.Prompt;
import burp.api.montoya.ai.chat.PromptResponse;
import burp.api.montoya.ai.chat.PromptException;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import javax.swing.event.ChangeEvent;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.JsonNode;

public class AIGraphqlPentester implements BurpExtension, ExtensionUnloadingHandler {
    
    private MontoyaApi api;
    private Logging logging;
    private Http http;
    private Ai ai;
    private ExecutorService executor;
    private ObjectMapper objectMapper;
    
    private JPanel mainPanel;
    private JTextField endpointField;
    private JTextArea schemaArea;
    private JTextArea targetQueryArea;
    private JTextArea testTypesArea;
    private JTextArea resultsArea;
    private JTextArea customMessageArea;
    private JTextArea customMessageResponseArea;
    private JTextField ragEndpointField;
    private JSpinner ragLambdaSpinner;
    private JSpinner ragDocsSpinner;
    private JLabel aiStatusLabel;
    private JButton introspectButton;
    private JButton parseButton;
    private JButton generateButton;
    private JButton sendMessageButton;
    private JButton copyToRepeaterButton;
    private JButton copyToIntruderButton;

    private final Map<String, Object> cache = new ConcurrentHashMap<>();
    private String extractedSchema = "";
    
    @Override
    public Set<EnhancedCapability> enhancedCapabilities() {
        return Set.of(EnhancedCapability.AI_FEATURES);
    }
    
    @Override
    public void initialize(MontoyaApi api) {
        this.api = api;
        this.logging = api.logging();
        this.http = api.http();
        this.ai = api.ai();
        this.executor = Executors.newCachedThreadPool();
        this.objectMapper = new ObjectMapper();
        
        api.extension().setName("AI GraphQL Pentester");
        api.extension().registerUnloadingHandler(this);
        
        logging.logToOutput("AI GraphQL Pentester loaded successfully");
        logging.logToOutput("AI Enabled: " + ai.isEnabled());

        SwingUtilities.invokeLater(() -> {
            createGui();
        });
    }
    
    
    private void createGui() {
        mainPanel = new JPanel(new BorderLayout());
        
        JTabbedPane tabbedPane = new JTabbedPane();
        
        tabbedPane.addTab("Schema & Testing", createMainTab());
        tabbedPane.addTab("RAG Configuration", createRagTab());
        tabbedPane.addTab("Custom Messages", createCustomMessageTab());
        tabbedPane.addTab("AI Status", createAiStatusTab());
        
        // Add tab change listener to update AI status display only
        tabbedPane.addChangeListener(this::onTabChanged);
        
        mainPanel.add(tabbedPane, BorderLayout.CENTER);
        
        api.userInterface().registerSuiteTab("AI GraphQL Pentester", mainPanel);
    }
    
    private JPanel createMainTab() {
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        
        JPanel topPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        
        gbc.insets = new Insets(5, 5, 5, 5);
        gbc.anchor = GridBagConstraints.WEST;
        
        gbc.gridx = 0; gbc.gridy = 0;
        topPanel.add(new JLabel("GraphQL Endpoint:"), gbc);
        
        gbc.gridx = 1; gbc.weightx = 1.0; gbc.fill = GridBagConstraints.HORIZONTAL;
        endpointField = new JTextField("https://example.com/graphql");
        topPanel.add(endpointField, gbc);
        
        gbc.gridx = 2; gbc.weightx = 0;
        introspectButton = new JButton("Introspect Schema");
        introspectButton.addActionListener(this::introspectSchema);
        topPanel.add(introspectButton, gbc);
        
        panel.add(topPanel, BorderLayout.NORTH);
        
        JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
        splitPane.setResizeWeight(0.3);
        
        JPanel schemaPanel = new JPanel(new BorderLayout());
        schemaPanel.setBorder(new TitledBorder("GraphQL Schema (JSON)"));
        
        schemaArea = new JTextArea(8, 40);
        schemaArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 12));
        schemaArea.setText("// Paste GraphQL schema JSON here or use introspection");
        JScrollPane schemaScroll = new JScrollPane(schemaArea);
        schemaPanel.add(schemaScroll, BorderLayout.CENTER);
        
        JPanel schemaButtons = new JPanel(new FlowLayout());
        parseButton = new JButton("Parse Schema");
        parseButton.addActionListener(this::parseSchema);
        schemaButtons.add(parseButton);
        schemaPanel.add(schemaButtons, BorderLayout.SOUTH);
        
        JPanel testingPanel = new JPanel(new BorderLayout());
        testingPanel.setBorder(new TitledBorder("Testing Configuration"));
        
        JPanel testConfig = new JPanel(new GridBagLayout());
        gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5);
        gbc.anchor = GridBagConstraints.NORTHWEST;
        
        gbc.gridx = 0; gbc.gridy = 0;
        testConfig.add(new JLabel("Target Query/Mutation:"), gbc);
        
        gbc.gridx = 0; gbc.gridy = 1; gbc.weightx = 1.0; gbc.fill = GridBagConstraints.BOTH;
        targetQueryArea = new JTextArea(4, 40);
        targetQueryArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 12));
        targetQueryArea.setText("// Paste specific GraphQL query/mutation to test (leave empty for bulk generation)");
        JScrollPane targetScroll = new JScrollPane(targetQueryArea);
        testConfig.add(targetScroll, gbc);
        
        gbc.gridx = 0; gbc.gridy = 2; gbc.weighty = 0;
        testConfig.add(new JLabel("Test Types:"), gbc);
        
        gbc.gridx = 0; gbc.gridy = 3; gbc.weighty = 1.0;
        testTypesArea = new JTextArea(3, 40);
        testTypesArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 12));
        testTypesArea.setText("SQL Injection, Authorization Bypass, DoS, Information Disclosure, Input Validation Bypass");
        JScrollPane typesScroll = new JScrollPane(testTypesArea);
        testConfig.add(typesScroll, gbc);
        
        testingPanel.add(testConfig, BorderLayout.CENTER);
        
        JPanel buttonPanel = new JPanel(new FlowLayout());
        generateButton = new JButton("Generate Malicious Queries");
        generateButton.addActionListener(this::generateQueries);
        // Always keep button enabled - show warning if AI is not available
        generateButton.setEnabled(true);
        buttonPanel.add(generateButton);
        testingPanel.add(buttonPanel, BorderLayout.SOUTH);
        
        JSplitPane upperSplit = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
        upperSplit.setResizeWeight(0.5);
        upperSplit.setLeftComponent(schemaPanel);
        upperSplit.setRightComponent(testingPanel);
        
        splitPane.setTopComponent(upperSplit);
        
        JPanel resultsPanel = new JPanel(new BorderLayout());
        resultsPanel.setBorder(new TitledBorder("Generated Queries & Results"));

        resultsArea = new JTextArea(15, 80);
        resultsArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 12));
        resultsArea.setEditable(false);
        resultsArea.setText(getUsageInstructions());
        JScrollPane resultsScroll = new JScrollPane(resultsArea);
        resultsPanel.add(resultsScroll, BorderLayout.CENTER);

        // Add action buttons panel
        JPanel resultsButtonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));

        copyToRepeaterButton = new JButton("Send to Repeater");
        copyToRepeaterButton.setEnabled(false);
        copyToRepeaterButton.setToolTipText("<html>Send query to Repeater for manual testing<br>• Select specific query text, or<br>• Use first generated query if nothing selected</html>");
        copyToRepeaterButton.addActionListener(this::sendToRepeater);
        resultsButtonPanel.add(copyToRepeaterButton);

        copyToIntruderButton = new JButton("Send to Intruder");
        copyToIntruderButton.setEnabled(false);
        copyToIntruderButton.setToolTipText("<html>Send query to Intruder for automated testing<br>• Select specific query text, or<br>• Use first generated query if nothing selected</html>");
        copyToIntruderButton.addActionListener(this::sendToIntruder);
        resultsButtonPanel.add(copyToIntruderButton);

        JButton showInstructionsButton = new JButton("Show Usage Instructions");
        showInstructionsButton.addActionListener(e -> {
            resultsArea.setText(getUsageInstructions());
            copyToRepeaterButton.setEnabled(false);
            copyToIntruderButton.setEnabled(false);
        });
        resultsButtonPanel.add(showInstructionsButton);

        resultsPanel.add(resultsButtonPanel, BorderLayout.SOUTH);

        splitPane.setBottomComponent(resultsPanel);
        
        panel.add(splitPane, BorderLayout.CENTER);
        
        return panel;
    }
    
    private JPanel createAiStatusTab() {
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        
        JPanel statusPanel = new JPanel(new GridBagLayout());
        statusPanel.setBorder(new TitledBorder("Montoya AI Status"));
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5);
        gbc.anchor = GridBagConstraints.WEST;
        
        gbc.gridx = 0; gbc.gridy = 0;
        statusPanel.add(new JLabel("AI Enabled:"), gbc);
        
        gbc.gridx = 1;
        aiStatusLabel = new JLabel(ai.isEnabled() ? "✓ Available" : "✗ Not Available");
        aiStatusLabel.setForeground(ai.isEnabled() ? Color.GREEN : Color.RED);
        statusPanel.add(aiStatusLabel, gbc);
        
        panel.add(statusPanel, BorderLayout.NORTH);
        
        JTextArea aiInfo = new JTextArea();
        aiInfo.setEditable(false);
        aiInfo.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 12));
        aiInfo.setText("Montoya AI Integration:\n\n" +
                "This extension uses Burp Suite's built-in AI capabilities for GraphQL security testing.\n\n" +
                "AI Status: " + (ai.isEnabled() ? "ENABLED" : "DISABLED") + "\n\n" +
                "Features:\n" +
                "• Uses Burp's native AI for security analysis\n" +
                "• No external API keys required\n" +
                "• Fully integrated with Burp Suite Professional\n" +
                "• Complies with BApp Store requirements\n\n" +
                "Requirements:\n" +
                "• Burp Suite Professional with AI features\n" +
                "• Extension must be granted AI capability permissions\n" +
                "• Montoya API 2025.8 or later\n\n" +
                "If AI is not enabled:\n" +
                "1. Ensure you're using Burp Suite Professional\n" +
                "2. Check that AI features are available in your license\n" +
                "3. Restart Burp Suite if needed\n" +
                "4. Contact PortSwigger support if issues persist\n\n" +
                "Security Notice:\n" +
                "All AI processing happens within Burp Suite's secure environment.\n" +
                "No data is sent to external services.");
        
        JScrollPane infoScroll = new JScrollPane(aiInfo);
        panel.add(infoScroll, BorderLayout.CENTER);
        
        return panel;
    }
    
    private JPanel createRagTab() {
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        
        JPanel configPanel = new JPanel(new GridBagLayout());
        configPanel.setBorder(new TitledBorder("RAG Service Configuration (Optional)"));
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5);
        gbc.anchor = GridBagConstraints.WEST;
        
        gbc.gridx = 0; gbc.gridy = 0;
        configPanel.add(new JLabel("RAG Endpoint:"), gbc);
        
        gbc.gridx = 1; gbc.weightx = 1.0; gbc.fill = GridBagConstraints.HORIZONTAL;
        ragEndpointField = new JTextField("http://localhost:50001", 30);
        configPanel.add(ragEndpointField, gbc);
        
        gbc.gridx = 0; gbc.gridy = 1; gbc.weightx = 0; gbc.fill = GridBagConstraints.NONE;
        configPanel.add(new JLabel("Lambda Multiplier (0.0=diversity, 1.0=relevance):"), gbc);
        
        gbc.gridx = 1;
        ragLambdaSpinner = new JSpinner(new SpinnerNumberModel(0.7, 0.0, 1.0, 0.1));
        ragLambdaSpinner.setPreferredSize(new Dimension(80, 25)); // Width for 4 digits
        configPanel.add(ragLambdaSpinner, gbc);
        
        gbc.gridx = 0; gbc.gridy = 2;
        configPanel.add(new JLabel("Number of Documents (1-20):"), gbc);
        
        gbc.gridx = 1;
        ragDocsSpinner = new JSpinner(new SpinnerNumberModel(5, 1, 20, 1));
        configPanel.add(ragDocsSpinner, gbc);
        
        panel.add(configPanel, BorderLayout.NORTH);
        
        JTextArea ragInfo = new JTextArea();
        ragInfo.setEditable(false);
        ragInfo.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 12));
        ragInfo.setText("RAG Integration Information:\n\n" +
                "• RAG (Retrieval-Augmented Generation) can enhance testing with external knowledge\n" +
                "• This is an OPTIONAL feature that works alongside Montoya AI\n" +
                "• Configure your RAG service endpoint above if available\n" +
                "• Lambda multiplier controls relevance vs diversity balance\n" +
                "• Higher document count provides more comprehensive coverage\n" +
                "• RAG queries are cached to prevent duplicate expensive operations\n\n" +
                "Expected RAG API Format:\n" +
                "POST /similarity_search\n" +
                "{\n" +
                "  \"query\": \"security testing query\",\n" +
                "  \"k\": 5,\n" +
                "  \"search_type\": \"mmr\",\n" +
                "  \"fetch_k\": 15,\n" +
                "  \"lambda_mult\": 0.7\n" +
                "}\n\n" +
                "Response:\n" +
                "{\n" +
                "  \"results\": [\n" +
                "    {\n" +
                "      \"content\": \"security knowledge content\",\n" +
                "      \"metadata\": {...}\n" +
                "    }\n" +
                "  ]\n" +
                "}\n\n" +
                "Note: RAG integration is optional. The extension works fully with Montoya AI alone.");
        
        JScrollPane infoScroll = new JScrollPane(ragInfo);
        panel.add(infoScroll, BorderLayout.CENTER);
        
        return panel;
    }
    
    private JPanel createCustomMessageTab() {
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        
        JPanel messagePanel = new JPanel(new BorderLayout());
        messagePanel.setBorder(new TitledBorder("Custom Message to Montoya AI"));
        
        customMessageArea = new JTextArea(6, 60);
        customMessageArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 12));
        customMessageArea.setText("Enter your custom message to Montoya AI for enhanced GraphQL security testing...");
        JScrollPane messageScroll = new JScrollPane(customMessageArea);
        messagePanel.add(messageScroll, BorderLayout.CENTER);
        
        JPanel buttonPanel = new JPanel(new FlowLayout());
        sendMessageButton = new JButton("Send Custom Message");
        sendMessageButton.addActionListener(this::sendCustomMessage);
        // Always keep button enabled - show warning if AI is not available
        sendMessageButton.setEnabled(true);
        buttonPanel.add(sendMessageButton);
        messagePanel.add(buttonPanel, BorderLayout.SOUTH);
        
        // Create a split pane for top (message input) and bottom (response and examples)
        JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
        splitPane.setResizeWeight(0.3);
        splitPane.setTopComponent(messagePanel);
        
        // Create bottom panel with response area and examples
        JPanel bottomPanel = new JPanel(new BorderLayout(5, 5));
        
        // AI Response area
        JPanel responsePanel = new JPanel(new BorderLayout());
        responsePanel.setBorder(new TitledBorder("Montoya AI Response"));
        
        customMessageResponseArea = new JTextArea(8, 60);
        customMessageResponseArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 12));
        customMessageResponseArea.setEditable(false);
        customMessageResponseArea.setText("AI responses will appear here...");
        JScrollPane responseScroll = new JScrollPane(customMessageResponseArea);
        responsePanel.add(responseScroll, BorderLayout.CENTER);
        
        bottomPanel.add(responsePanel, BorderLayout.CENTER);
        
        // Examples area (smaller)
        JTextArea examplesArea = new JTextArea(6, 60);
        examplesArea.setEditable(false);
        examplesArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 11));
        examplesArea.setText("Example Custom Messages:\n" +
                "• \"Focus on NoSQL injection in GraphQL mutations\"\n" +
                "• \"Generate authentication bypass variants\"\n" +
                "• \"Create resource exhaustion test queries\"\n" +
                "• \"Test for field access bypasses\"\n" +
                "• \"Generate introspection disclosure queries\"\n\n" +
                "AI Status: " + (ai.isEnabled() ? "READY" : "NOT AVAILABLE"));
        
        JScrollPane examplesScroll = new JScrollPane(examplesArea);
        examplesScroll.setBorder(new TitledBorder("Usage Examples"));
        bottomPanel.add(examplesScroll, BorderLayout.SOUTH);
        
        splitPane.setBottomComponent(bottomPanel);
        panel.add(splitPane, BorderLayout.CENTER);
        
        return panel;
    }
    
    private void onTabChanged(ChangeEvent e) {
        JTabbedPane tabbedPane = (JTabbedPane) e.getSource();
        int selectedIndex = tabbedPane.getSelectedIndex();

        // If AI Status tab is selected, update the status display
        if (selectedIndex == 3) { // AI Status tab index (now 4th tab)
            updateAiStatus();
        }
    }
    
    private void updateAiStatus() {
        if (aiStatusLabel != null) {
            boolean aiEnabled = ai.isEnabled();
            SwingUtilities.invokeLater(() -> {
                aiStatusLabel.setText(aiEnabled ? "✓ Available" : "✗ Not Available");
                aiStatusLabel.setForeground(aiEnabled ? Color.GREEN : Color.RED);

                // Update the info text as well
                updateAiInfoText(aiEnabled);
            });
        }
    }
    
    private void updateAiInfoText(boolean aiEnabled) {
        // Find the AI info text area and update it
        Component[] components = mainPanel.getComponents();
        for (Component comp : components) {
            if (comp instanceof JTabbedPane) {
                JTabbedPane tabbedPane = (JTabbedPane) comp;
                Component aiStatusTab = tabbedPane.getComponentAt(3); // AI Status tab (now 4th tab)
                if (aiStatusTab instanceof JPanel) {
                    updateAiInfoTextRecursive((Container) aiStatusTab, aiEnabled);
                }
            }
        }
    }
    
    private void updateAiInfoTextRecursive(Container container, boolean aiEnabled) {
        for (Component comp : container.getComponents()) {
            if (comp instanceof JTextArea) {
                JTextArea textArea = (JTextArea) comp;
                if (textArea.getText().contains("Montoya AI Integration:")) {
                    textArea.setText(getAiInfoText(aiEnabled));
                }
            } else if (comp instanceof Container) {
                updateAiInfoTextRecursive((Container) comp, aiEnabled);
            }
        }
    }
    
    private String getAiInfoText(boolean aiEnabled) {
        return "Montoya AI Integration:\n\n" +
                "This extension uses Burp Suite's built-in AI capabilities for GraphQL security testing.\n\n" +
                "AI Status: " + (aiEnabled ? "ENABLED" : "DISABLED") + "\n\n" +
                "Features:\n" +
                "• Uses Burp's native AI for security analysis\n" +
                "• No external API keys required\n" +
                "• Fully integrated with Burp Suite Professional\n" +
                "• Complies with BApp Store requirements\n\n" +
                "Requirements:\n" +
                "• Burp Suite Professional with AI features\n" +
                "• Extension must be granted AI capability permissions\n" +
                "• Montoya API 2025.8 or later\n\n" +
                (aiEnabled ? 
                    "✓ AI is currently enabled and ready for use!\n\n" +
                    "You can now:\n" +
                    "• Generate malicious GraphQL queries\n" +
                    "• Send custom messages to Montoya AI\n" +
                    "• Use AI-powered security testing features\n\n" :
                    "AI Status: Not enabled\n\n" +
                    "To enable AI:\n" +
                    "1. Go to Extensions > Installed tab\n" +
                    "2. Find 'AI GraphQL Pentester' extension\n" +
                    "3. Check the 'Use AI' checkbox\n" +
                    "4. Return to this tab to see updated status\n\n"
                ) +
                "Security Notice:\n" +
                "All AI processing happens within Burp Suite's secure environment.\n" +
                "No data is sent to external services.";
    }
    
    private void introspectSchema(ActionEvent e) {
        String endpoint = endpointField.getText().trim();
        if (endpoint.isEmpty()) {
            showError("Please enter a GraphQL endpoint URL");
            return;
        }
        
        introspectButton.setEnabled(false);
        resultsArea.setText("Introspecting GraphQL schema...\n");
        
        executor.submit(() -> {
            try {
                String introspectionQuery = "{"
                    + "\"query\": \"query IntrospectionQuery { __schema { queryType { name } mutationType { name } subscriptionType { name } types { ...FullType } directives { name description locations args { ...InputValue } } } } fragment FullType on __Type { kind name description fields(includeDeprecated: true) { name description args { ...InputValue } type { ...TypeRef } isDeprecated deprecationReason } inputFields { ...InputValue } interfaces { ...TypeRef } enumValues(includeDeprecated: true) { name description isDeprecated deprecationReason } possibleTypes { ...TypeRef } } fragment InputValue on __InputValue { name description type { ...TypeRef } defaultValue } fragment TypeRef on __Type { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name } } } } } } } }\""
                    + "}";
                
                HttpRequest request = HttpRequest.httpRequestFromUrl(endpoint)
                    .withMethod("POST")
                    .withAddedHeader("Content-Type", "application/json")
                    .withBody(introspectionQuery);
                
                HttpRequestResponse requestResponse = http.sendRequest(request);
                HttpResponse response = requestResponse.response();
                
                if (response.statusCode() == 200) {
                    String responseBody = response.bodyToString();
                    
                    SwingUtilities.invokeLater(() -> {
                        schemaArea.setText(responseBody);
                        extractedSchema = responseBody;
                        resultsArea.append("Schema introspection completed successfully!\n");
                        resultsArea.append("Schema extracted and ready for testing.\n\n");
                        introspectButton.setEnabled(true);
                    });
                } else {
                    SwingUtilities.invokeLater(() -> {
                        showError("Introspection failed with status: " + response.statusCode());
                        resultsArea.append("Introspection failed. Status: " + response.statusCode() + "\n");
                        introspectButton.setEnabled(true);
                    });
                }
            } catch (Exception ex) {
                logging.logToError("Introspection error: " + ex.getMessage());
                SwingUtilities.invokeLater(() -> {
                    showError("Introspection error: " + ex.getMessage());
                    resultsArea.append("Error during introspection: " + ex.getMessage() + "\n");
                    introspectButton.setEnabled(true);
                });
            }
        });
    }
    
    private void parseSchema(ActionEvent e) {
        String schemaText = schemaArea.getText().trim();
        if (schemaText.isEmpty() || schemaText.startsWith("//")) {
            showError("Please provide a GraphQL schema JSON");
            return;
        }

        try {
            // Validate that the schema is valid JSON
            objectMapper.readTree(schemaText);
            extractedSchema = schemaText;
            resultsArea.setText("Schema parsed successfully!\n");
            resultsArea.append("Ready for malicious query generation.\n\n");
        } catch (Exception ex) {
            logging.logToError("Schema parsing error: " + ex.getMessage());
            showError("Invalid JSON schema: " + ex.getMessage());
        }
    }
    
    private void generateQueries(ActionEvent e) {
        if (!ai.isEnabled()) {
            showWarning("AI is not enabled!\n\n" +
                    "To use this feature, please enable AI:\n\n" +
                    "1. Go to Extensions → Installed tab\n" +
                    "2. Find 'AI GraphQL Pentester' extension\n" +
                    "3. Check the 'Use AI' checkbox\n" +
                    "4. Return here and try again");
            return;
        }
        
        if (extractedSchema.isEmpty()) {
            showError("Please first extract or parse a GraphQL schema");
            return;
        }
        
        String targetQuery = targetQueryArea.getText().trim();
        String testTypes = testTypesArea.getText().trim();
        
        if (testTypes.isEmpty()) {
            showError("Please specify test types");
            return;
        }
        
        generateButton.setEnabled(false);
        resultsArea.setText("Generating malicious GraphQL queries using Montoya AI...\n");
        
        executor.submit(() -> {
            try {
                String ragContext = getRagContext(testTypes);
                String aiPrompt = buildAiPrompt(extractedSchema, targetQuery, testTypes, ragContext);
                
                Prompt prompt = ai.prompt();
                PromptResponse aiResponse = prompt.execute(aiPrompt);
                String responseText = aiResponse.content();
                
                String processedQueries = processAiResponse(responseText);
                
                SwingUtilities.invokeLater(() -> {
                    resultsArea.setText("Generated Malicious GraphQL Queries:\n\n");
                    resultsArea.append(processedQueries);
                    resultsArea.append("\n\n" + getPostGenerationInstructions());
                    generateButton.setEnabled(true);
                    copyToRepeaterButton.setEnabled(true);
                    copyToIntruderButton.setEnabled(true);
                });
                
            } catch (PromptException ex) {
                logging.logToError("AI Prompt error: " + ex.getMessage());
                SwingUtilities.invokeLater(() -> {
                    resultsArea.append("AI Error: " + ex.getMessage() + "\n");
                    resultsArea.append("Please check AI availability and try again.\n");
                    generateButton.setEnabled(true);
                });
            } catch (Exception ex) {
                logging.logToError("Query generation error: " + ex.getMessage());
                SwingUtilities.invokeLater(() -> {
                    resultsArea.append("Error generating queries: " + ex.getMessage() + "\n");
                    generateButton.setEnabled(true);
                });
            }
        });
    }
    
    private void sendCustomMessage(ActionEvent e) {
        if (!ai.isEnabled()) {
            showWarning("AI is not enabled!\n\n" +
                    "To use this feature, please enable AI:\n\n" +
                    "1. Go to Extensions → Installed tab\n" +
                    "2. Find 'AI GraphQL Pentester' extension\n" +
                    "3. Check the 'Use AI' checkbox\n" +
                    "4. Return here and try again");
            return;
        }
        
        String customMessage = customMessageArea.getText().trim();
        if (customMessage.isEmpty() || customMessage.startsWith("Enter your")) {
            showError("Please enter a custom message");
            return;
        }
        
        sendMessageButton.setEnabled(false);
        customMessageResponseArea.setText("Processing custom message with Montoya AI...\n");
        
        executor.submit(() -> {
            try {
                String ragContext = getRagContext(customMessage);
                String enhancedPrompt = "GraphQL Security Expert Request: " + customMessage + 
                    "\n\nAdditional Context: " + ragContext + 
                    "\n\nPlease provide detailed security insights and recommendations for defensive testing purposes only.";
                
                Prompt prompt = ai.prompt();
                PromptResponse aiResponse = prompt.execute(enhancedPrompt);
                String responseText = aiResponse.content();
                
                SwingUtilities.invokeLater(() -> {
                    customMessageResponseArea.setText("Montoya AI Response:\n\n");
                    customMessageResponseArea.append(responseText);
                    customMessageResponseArea.append("\n\nResponse completed!\n");
                    sendMessageButton.setEnabled(true);
                });
                
            } catch (PromptException ex) {
                logging.logToError("AI Prompt error: " + ex.getMessage());
                SwingUtilities.invokeLater(() -> {
                    customMessageResponseArea.append("AI Error: " + ex.getMessage() + "\n");
                    customMessageResponseArea.append("Please check AI availability and try again.\n");
                    sendMessageButton.setEnabled(true);
                });
            } catch (Exception ex) {
                logging.logToError("Custom message error: " + ex.getMessage());
                SwingUtilities.invokeLater(() -> {
                    customMessageResponseArea.append("Error processing custom message: " + ex.getMessage() + "\n");
                    sendMessageButton.setEnabled(true);
                });
            }
        });
    }
    
    private String getRagContext(String query) {
        String ragEndpoint = ragEndpointField.getText().trim();
        if (ragEndpoint.isEmpty()) {
            return "";
        }
        
        String cacheKey = "rag_" + query.hashCode();
        if (cache.containsKey(cacheKey)) {
            return (String) cache.get(cacheKey);
        }
        
        try {
            double lambda = (Double) ragLambdaSpinner.getValue();
            int docs = (Integer) ragDocsSpinner.getValue();
            int fetchK = docs * 3;
            
            Map<String, Object> ragPayload = new HashMap<>();
            ragPayload.put("query", query);
            ragPayload.put("k", docs);
            ragPayload.put("search_type", "mmr");
            ragPayload.put("fetch_k", fetchK);
            ragPayload.put("lambda_mult", lambda);
            
            String jsonPayload = objectMapper.writeValueAsString(ragPayload);
            
            HttpRequest ragRequest = HttpRequest.httpRequestFromUrl(ragEndpoint + "/similarity_search")
                .withMethod("POST")
                .withAddedHeader("Content-Type", "application/json")
                .withBody(jsonPayload);
            
            HttpRequestResponse ragRequestResponse = http.sendRequest(ragRequest);
            HttpResponse ragResponse = ragRequestResponse.response();
            
            if (ragResponse.statusCode() == 200) {
                JsonNode responseNode = objectMapper.readTree(ragResponse.bodyToString());
                StringBuilder context = new StringBuilder();
                
                if (responseNode.has("results")) {
                    for (JsonNode result : responseNode.get("results")) {
                        if (result.has("content")) {
                            context.append(result.get("content").asText()).append("\n");
                        }
                    }
                }
                
                String ragContext = context.toString();
                cache.put(cacheKey, ragContext);
                return ragContext;
            }
        } catch (Exception ex) {
            logging.logToError("RAG integration error: " + ex.getMessage());
        }
        
        return "";
    }
    
    private String buildAiPrompt(String schema, String targetQuery, String testTypes, String ragContext) {
        StringBuilder prompt = new StringBuilder();
        prompt.append("You are a GraphQL security testing expert conducting authorized defensive security testing. ");
        
        if (!ragContext.isEmpty()) {
            prompt.append("Use this security knowledge: ").append(ragContext).append("\n\n");
        }
        
        prompt.append("GraphQL Schema: ").append(schema).append("\n\n");
        
        if (!targetQuery.isEmpty() && !targetQuery.startsWith("//")) {
            prompt.append("Generate malicious variants of this specific query: ").append(targetQuery).append("\n\n");
        } else {
            prompt.append("Generate multiple malicious GraphQL queries based on the schema.\n\n");
        }
        
        prompt.append("Focus on these attack types: ").append(testTypes).append("\n\n");
        prompt.append("For each query:\n");
        prompt.append("1. Provide the GraphQL query in single-line format\n");
        prompt.append("2. Explain the attack vector being tested\n");
        prompt.append("3. Include expected security impact\n\n");
        prompt.append("Generate comprehensive test cases for authorized security testing only. ");
        prompt.append("All generated content is for defensive security purposes and authorized testing scenarios.");
        
        return prompt.toString();
    }
    
    private String processAiResponse(String response) {
        StringBuilder processed = new StringBuilder();
        String[] lines = response.split("\n");
        
        Pattern graphqlPattern = Pattern.compile(".*?(query|mutation|subscription)\\s*\\{.*?\\}", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
        
        for (String line : lines) {
            String normalizedLine = normalizeUnicode(line);
            
            Matcher matcher = graphqlPattern.matcher(normalizedLine);
            if (matcher.find()) {
                String query = matcher.group().trim();
                String singleLineQuery = convertToSingleLine(query);
                processed.append("QUERY: ").append(singleLineQuery).append("\n");
            } else if (!normalizedLine.trim().isEmpty()) {
                processed.append(normalizedLine).append("\n");
            }
        }
        
        return processed.toString();
    }
    
    private String convertToSingleLine(String query) {
        return query.replaceAll("\\s+", " ")
                   .replaceAll("\\{\\s+", "{ ")
                   .replaceAll("\\s+\\}", " }")
                   .trim();
    }
    
    private String normalizeUnicode(String text) {
        return text.replace("\u2018", "'")
                  .replace("\u2019", "'")
                  .replace("\u201C", "\"")
                  .replace("\u201D", "\"")
                  .replace("\u2013", "-")
                  .replace("\u2014", "-");
    }

    private String getUsageInstructions() {
        return "=== HOW TO USE AI-GENERATED GRAPHQL ATTACKS ===\n\n" +
                "GETTING STARTED:\n" +
                "1. Enter your GraphQL endpoint URL\n" +
                "2. Click 'Introspect Schema' or paste schema JSON manually\n" +
                "3. (Optional) Specify a target query/mutation to test\n" +
                "4. Select attack types (SQL Injection, Auth Bypass, etc.)\n" +
                "5. Click 'Generate Malicious Queries' to create test cases\n\n" +
                "USING GENERATED QUERIES WITH BURP TOOLS:\n\n" +
                "METHOD 1 - Repeater (Manual Testing):\n" +
                "• Select a specific AI-generated query from the results below\n" +
                "• Click 'Send to Repeater' to send the selected query\n" +
                "• If nothing is selected, the first query will be sent\n" +
                "• In Repeater: modify headers, analyze responses, refine attacks\n" +
                "• Test authentication, authorization, and injection vectors\n\n" +
                "METHOD 2 - Intruder (Automated Testing):\n" +
                "• Select a specific AI-generated query from the results below\n" +
                "• Click 'Send to Intruder' to load the selected query\n" +
                "• If nothing is selected, the first query will be used\n" +
                "• Set payload positions on query parameters\n" +
                "• Use wordlists to fuzz inputs (SQL, XSS, traversal payloads)\n" +
                "• Analyze response codes, lengths, and error messages\n\n" +
                "METHOD 3 - Manual Copy & Execute:\n" +
                "• Copy individual queries from the results area\n" +
                "• Send to Repeater, Intruder, or external tools\n" +
                "• Use in curl commands or GraphQL clients\n" +
                "• Test in different authentication contexts\n\n" +
                "BEST PRACTICES:\n" +
                "✓ Test each query variant individually for accuracy\n" +
                "✓ Use Repeater to understand baseline behavior first\n" +
                "✓ Leverage Intruder for parameter fuzzing and brute force\n" +
                "✓ Compare responses to identify vulnerabilities\n" +
                "✓ Document findings in Burp's issue tracker\n" +
                "✓ Ensure you have proper authorization for testing\n\n" +
                "TIPS:\n" +
                "• Check 'HTTP history' to see all requests sent\n" +
                "• Use 'Comparer' to diff responses for subtle changes\n" +
                "• Combine with Scanner for comprehensive coverage\n" +
                "• Save successful queries for future testing\n\n" +
                "READY TO START:\n" +
                "Configure your endpoint above and generate your first batch of test queries!\n";
    }

    private String getPostGenerationInstructions() {
        return "=== NEXT STEPS ===\n\n" +
                "✓ Queries generated successfully!\n\n" +
                "QUICK ACTIONS:\n" +
                "• Select a specific query above (or use first query if none selected)\n" +
                "• Click 'Send to Repeater' → Test queries manually with full control\n" +
                "• Click 'Send to Intruder' → Automate testing with payload fuzzing\n" +
                "• Copy specific queries above → Use in external tools or curl\n\n" +
                "RECOMMENDED WORKFLOW:\n" +
                "1. Select a query from the results above\n" +
                "2. Send to Repeater first to understand baseline responses\n" +
                "3. Identify interesting queries that produce different behaviors\n" +
                "4. Use Intruder to fuzz parameters in promising queries\n" +
                "5. Document any vulnerabilities found\n\n" +
                "Need help? Click 'Show Usage Instructions' for detailed guidance.";
    }

    private void sendToRepeater(ActionEvent e) {
        String endpoint = endpointField.getText().trim();
        if (endpoint.isEmpty()) {
            showError("Please enter a GraphQL endpoint URL first");
            return;
        }

        // Check if user has selected specific text
        String selectedText = resultsArea.getSelectedText();
        String queryToSend;

        if (selectedText != null && !selectedText.trim().isEmpty()) {
            // User selected specific text - try to extract query from it
            queryToSend = extractQueryFromSelection(selectedText);
            if (queryToSend.isEmpty()) {
                showError("Selected text does not contain a valid GraphQL query.\n\nPlease select a query like: { user(id: \"1\") { name } }");
                return;
            }
        } else {
            // No selection - use first query from results
            String resultsText = resultsArea.getText();
            queryToSend = extractFirstQuery(resultsText);
            if (queryToSend.isEmpty()) {
                showError("No valid GraphQL query found in results");
                return;
            }
        }

        try {
            // Check if queryToSend is already a complete JSON object (with query and variables)
            String jsonPayload;
            if (queryToSend.trim().startsWith("{") && queryToSend.contains("\"query\"")) {
                // Already in JSON format, use as-is
                jsonPayload = queryToSend;
            } else {
                // Plain GraphQL query, wrap it in JSON
                jsonPayload = "{\"query\": \"" + escapeJson(queryToSend) + "\"}";
            }

            HttpRequest request = HttpRequest.httpRequestFromUrl(endpoint)
                .withMethod("POST")
                .withAddedHeader("Content-Type", "application/json")
                .withBody(jsonPayload);

            api.repeater().sendToRepeater(request);
            logging.logToOutput("Query sent to Repeater: " + queryToSend);
            showInfo("Query sent to Repeater successfully!\n\nCheck the Repeater tab to analyze the request.");
        } catch (Exception ex) {
            logging.logToError("Error sending to Repeater: " + ex.getMessage());
            showError("Failed to send to Repeater: " + ex.getMessage());
        }
    }

    private void sendToIntruder(ActionEvent e) {
        String endpoint = endpointField.getText().trim();
        if (endpoint.isEmpty()) {
            showError("Please enter a GraphQL endpoint URL first");
            return;
        }

        // Check if user has selected specific text
        String selectedText = resultsArea.getSelectedText();
        String queryToSend;

        if (selectedText != null && !selectedText.trim().isEmpty()) {
            // User selected specific text - try to extract query from it
            queryToSend = extractQueryFromSelection(selectedText);
            if (queryToSend.isEmpty()) {
                showError("Selected text does not contain a valid GraphQL query.\n\nPlease select a query like: { user(id: \"1\") { name } }");
                return;
            }
        } else {
            // No selection - use first query from results
            String resultsText = resultsArea.getText();
            queryToSend = extractFirstQuery(resultsText);
            if (queryToSend.isEmpty()) {
                showError("No valid GraphQL query found in results");
                return;
            }
        }

        try {
            // Check if queryToSend is already a complete JSON object (with query and variables)
            String jsonPayload;
            if (queryToSend.trim().startsWith("{") && queryToSend.contains("\"query\"")) {
                // Already in JSON format, use as-is
                jsonPayload = queryToSend;
            } else {
                // Plain GraphQL query, wrap it in JSON
                jsonPayload = "{\"query\": \"" + escapeJson(queryToSend) + "\"}";
            }

            HttpRequest request = HttpRequest.httpRequestFromUrl(endpoint)
                .withMethod("POST")
                .withAddedHeader("Content-Type", "application/json")
                .withBody(jsonPayload);

            api.intruder().sendToIntruder(request);
            logging.logToOutput("Query sent to Intruder: " + queryToSend);
            showInfo("Query sent to Intruder successfully!\n\nCheck the Intruder tab to configure attack positions and payloads.");
        } catch (Exception ex) {
            logging.logToError("Error sending to Intruder: " + ex.getMessage());
            showError("Failed to send to Intruder: " + ex.getMessage());
        }
    }

    private String extractQueryFromSelection(String selectedText) {
        // Extract GraphQL query from user-selected text
        // This is more lenient than extractFirstQuery since user explicitly selected it

        String trimmed = selectedText.trim();

        // First, check if this is a JSON object with "query" and possibly "variables" fields
        if (trimmed.startsWith("{") && trimmed.contains("\"query\"")) {
            try {
                JsonNode jsonNode = objectMapper.readTree(trimmed);
                if (jsonNode.has("query")) {
                    // Return the entire JSON if it has both query and variables
                    // This preserves the complete GraphQL request structure
                    return trimmed;
                }
            } catch (Exception e) {
                // Not valid JSON, continue with other extraction methods
                logging.logToError("Selection is not valid JSON: " + e.getMessage());
            }
        }

        // Check if the selection itself is a valid GraphQL query
        if (trimmed.startsWith("{") && trimmed.contains("}")) {
            return trimmed;
        }

        // Try to extract query from "QUERY: ..." format
        Pattern queryPattern = Pattern.compile("QUERY:\\s*(.+?)(?=\\n|$)", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
        Matcher matcher = queryPattern.matcher(trimmed);

        if (matcher.find()) {
            String query = matcher.group(1).trim();
            if (query.contains("{") && query.contains("}")) {
                return query;
            }
        }

        // Try to find any GraphQL query in the selection
        Pattern graphqlPattern = Pattern.compile("(?:query|mutation|subscription)?\\s*\\{(?:[^{}]|\\{[^{}]*\\})*\\}", Pattern.CASE_INSENSITIVE);
        matcher = graphqlPattern.matcher(trimmed);

        if (matcher.find()) {
            return matcher.group().trim();
        }

        return "";
    }

    private String extractFirstQuery(String text) {
        // First, try to find queries marked with "QUERY:" prefix
        Pattern queryPattern = Pattern.compile("QUERY:\\s*(.+?)(?=\\n(?!\\s)|$)", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
        Matcher matcher = queryPattern.matcher(text);

        if (matcher.find()) {
            String query = matcher.group(1).trim();
            // Validate it looks like a GraphQL query
            if (query.contains("{") && query.contains("}")) {
                return query;
            }
        }

        // Fallback: try to find any GraphQL query/mutation with or without keywords
        // This pattern matches queries with nested braces: { field { subfield } }
        Pattern graphqlPattern = Pattern.compile("(?:query|mutation|subscription)?\\s*\\{(?:[^{}]|\\{[^{}]*\\})*\\}", Pattern.CASE_INSENSITIVE);
        matcher = graphqlPattern.matcher(text);

        if (matcher.find()) {
            return matcher.group().trim();
        }

        return "";
    }

    private String escapeJson(String text) {
        return text.replace("\\", "\\\\")
                   .replace("\"", "\\\"")
                   .replace("\n", "\\n")
                   .replace("\r", "\\r")
                   .replace("\t", "\\t");
    }


    private void showInfo(String message) {
        JOptionPane.showMessageDialog(
            api.userInterface().swingUtils().suiteFrame(),
            message,
            "Success",
            JOptionPane.INFORMATION_MESSAGE
        );
    }

    private void showWarning(String message) {
        JOptionPane.showMessageDialog(
            api.userInterface().swingUtils().suiteFrame(),
            message,
            "AI Not Enabled",
            JOptionPane.WARNING_MESSAGE
        );
    }

    private void showError(String message) {
        JOptionPane.showMessageDialog(
            api.userInterface().swingUtils().suiteFrame(),
            message,
            "Error",
            JOptionPane.ERROR_MESSAGE
        );
    }
    
    @Override
    public void extensionUnloaded() {
        logging.logToOutput("AI GraphQL Pentester unloading...");

        if (executor != null && !executor.isShutdown()) {
            executor.shutdown();
        }

        cache.clear();

        logging.logToOutput("AI GraphQL Pentester unloaded successfully");
    }
}